<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java笔记-数组 | Future-tt</title><meta name="keywords" content="Java笔记"><meta name="author" content="Future-T"><meta name="copyright" content="Future-T"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组在某些情况下，虽然可以使用单个变量来存储信息，但是如果需要存储的信息较多（例如存储 50 名学生的成绩），这时再依次创建变量声明并赋值显得非常麻烦。 随着处理的信息量越来越大，工作也就越来越烦琐，这时可以使用数组或集合来存储信息。通过使用数组，可以在很大程度上缩短和简化程序代码，从而提高应用程序的效率。 数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记-数组">
<meta property="og:url" content="http://yoursite.com/2020/05/13/Java%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="Future-tt">
<meta property="og:description" content="数组在某些情况下，虽然可以使用单个变量来存储信息，但是如果需要存储的信息较多（例如存储 50 名学生的成绩），这时再依次创建变量声明并赋值显得非常麻烦。 随着处理的信息量越来越大，工作也就越来越烦琐，这时可以使用数组或集合来存储信息。通过使用数组，可以在很大程度上缩短和简化程序代码，从而提高应用程序的效率。 数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/14/Y08rvD.jpg">
<meta property="article:published_time" content="2020-05-13T07:26:33.000Z">
<meta property="article:modified_time" content="2020-05-18T10:01:18.505Z">
<meta property="article:author" content="Future-T">
<meta property="article:tag" content="Java笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/05/14/Y08rvD.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/05/13/Java%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java笔记-数组',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-05-18 18:01:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/yejiaotouming.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery"><i class="fa-fw fas fa-gallery"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2020/05/14/Y08rvD.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Future-tt</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery"><i class="fa-fw fas fa-gallery"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java笔记-数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-13T07:26:33.000Z" title="发表于 2020-05-13 15:26:33">2020-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-18T10:01:18.505Z" title="更新于 2020-05-18 18:01:18">2020-05-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Java学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java笔记-数组"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在某些情况下，虽然可以使用单个变量来存储信息，但是如果需要存储的信息较多（例如存储 50 名学生的成绩），这时再依次创建变量声明并赋值显得非常麻烦。</p>
<p>随着处理的信息量越来越大，工作也就越来越烦琐，这时可以使用数组或集合来存储信息。通过使用数组，可以在很大程度上缩短和简化程序代码，从而提高应用程序的效率。</p>
<p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p>
<p>在计算机语言中数组是非常重要的集合类型，大部分计算机语言中数组具有如下三个基本特性：</p>
<ol>
<li> 一致性：数组只能保存相同数据类型元素，元素的数据类型可以是任何相同的数据类型。</li>
<li> 有序性：数组中的元素是有序的，通过下标访问。</li>
<li> 不可变性：数组一旦初始化，则长度（数组中元素的个数）不可变。</li>
</ol>
<p>总的来说，数组具有以下特点：</p>
<ul>
<li>数组可以是一维数组、二维数组或多维数组。</li>
<li>数值数组元素的默认值为 0，而引用元素的默认值为 null。</li>
<li>数组的索引从 0 开始，如果数组有 n 个元素，那么数组的索引是从 0 到（n-1）。</li>
<li>数组元素可以是任何类型，包括数组类型。</li>
<li>数组类型是从抽象基类 Array 派生的引用类型。</li>
</ul>
<p>注意：如果你熟悉 C/<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>，请注意，<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 数组的工作原理与它们不同。</p>
<p>在 Java 中数组的下标是从零开始的，很多计算机语言的数组下标也从零开始。Java 数组下标访问运算符是中括号，如 intArray[0]，表示访问 intArray 数组的第一个元素，0 是第一个元素的下标。Java 中的数组本身是引用数据类型，它的长度属性是 length。</p>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>当数组中每个元素都只带有一个下标时，这种数组就是“一维数组”。一维数组（one-dimensional array）实质上是一组相同类型数据的线性集合，是数组中最简单的一种数组。</p>
<p>数组是引用数据类型，引用数据类型在使用之前一定要做两件事情：声明和初始化。所以本文将重点介绍一维数组的创建、初始化和使用。</p>
<h4 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h4><p>为了在程序中使用一个数组，必须声明一个引用该数组的变量，并指明整个变量可以引用的数组类型。声明一维数组的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName;    // 数据类型[] 数组名;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[];    // 数据类型 数组名[];</span><br></pre></td></tr></table></figure>

<p>可见数组的声明有两种形式：一种是中括号”[]“跟在元素数据类型之后，另一种是中括号”[]“跟在变量名之后。</p>
<p>对于以上两种语法格式而言，<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 更推荐采用第一种声明格式，因为第一种格式不仅具有更好的语意，而且具有更好的可读性。对于第一种格式<code>type[] arrayName</code>，很容易理解这是定义一个变量，其中变量名是 arrayName，而变量类型是 type[]。</p>
<p>前面已经指出：type[] 确实是一种新类型，与 type 类型完全不同（例如 int 类型是基本类型，但 int[] 是引用类型）。因此，这种方式既容易理解，也符合定义变量的语法。但第二种格式<code>type arrayName[]</code>的可读性就差了，看起来好像定义了一个类型为 type 的变量，而变量名是 arrayName[]，这与真实的含义相去甚远。</p>
<p>提示：Java 的模仿者 <a target="_blank" rel="noopener" href="http://c.biancheng.net/csharp/">C#</a> 就不再支持<code>type arrayName[]</code>这种语法，它只支持第一种定义数组的语法。越来越多的语言不再支持<code>type arrayName[]</code>这种数组定义语法。</p>
<p>以上两种格式都可以声明一个数组，其中的数据类型既可以是基本数据类型，也可以是引用数据类型。数组名可以是任意合法的变量名。声明数组就是要告诉计算机该数组中数据的类型是什么。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] score;    <span class="comment">// 存储学生的成绩，类型为整型</span></span><br><span class="line"><span class="keyword">double</span>[] price;    <span class="comment">// 存储商品的价格，类型为浮点型</span></span><br><span class="line">String[] name;    <span class="comment">// 存储商品名称，类型为字符串型</span></span><br></pre></td></tr></table></figure>

<p>在声明数组时不需要规定数组的长度，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score[<span class="number">10</span>];    <span class="comment">// 这是错误的</span></span><br></pre></td></tr></table></figure>

<p><strong>分配空间</strong></p>
<p>声明了数组，只是得到了一个存放数组的变量，并没有为数组元素分配内存空间，不能使用。因此要为数组分配内存空间，这样数组的每一个元素才有一个空间进行存储。</p>
<p>简单地说，分配空间就是要告诉计算机在内存中为它分配几个连续的位置来存储数据。在 Java 中可以使用 new 关键字来给数组分配空间。分配空间的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = new type[size];    // 数组名 = new 数据类型[数组长度];</span><br></pre></td></tr></table></figure>

<p>其中，数组长度就是数组中能存放的元素个数，显然应该为大于 0 的整数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">price = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br><span class="line">name = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<p>这里的 score 是已经声明过的 int[] 类型的变量，当然也可以在声明数组时就给它分配空间，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = new type[size];    // 数据类型[] 数组名 = new 数据类型[数组长度];</span><br></pre></td></tr></table></figure>

<p><strong>例 1</strong></p>
<p>例如，声明并分配一个长度为 5 的 int 类型数组 arr，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>执行后 arr 数组在内存中的格式如图 1 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181016/3-1Q016111945238.jpg" alt="img"></p>
<p>在图 1 中 arr 为数组名称，方括号“[]”中的值为数组的下标。数组通过下标来区分数组中不同的元素，并且下标是从 0 开始的。因此这里包含 5 个元素的 arr 数组最大下标为 4。</p>
<p><strong>注意：</strong>一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。</p>
<p>尽管数组可以存储一组基本数据类型的元素，但是数组整体属于引用数据类型。当声明一个数组变量时，其实是创建了一个类型为“数据类型[]”（如 int[]、double[]、String[]）的数组对象，它具有表 1 所示的方法和属性。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center"><strong>名称</strong></th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>方法</strong></td>
<td align="center">clone()</td>
<td align="center">Object</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">equals(Object obj)</td>
<td align="center">boolean</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">getClass()</td>
<td align="center">Class&lt;?&gt;</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">hashCode()</td>
<td align="center">int</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">notify()</td>
<td align="center">void</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">notify All()</td>
<td align="center">void</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">toString()</td>
<td align="center">String</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">wait()</td>
<td align="center">void</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">wait(long timeout)</td>
<td align="center">void</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td align="center">wait(long timeout,int nanos)</td>
<td align="center">void</td>
</tr>
<tr>
<td><strong>属性</strong></td>
<td align="center">length</td>
<td align="center">int</td>
</tr>
</tbody></table>
<h4 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h4><p>Java 语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p>
<p>能不能只分配内存空间，不赋初始值呢？</p>
<p>不行，一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容为空，这个空也是一个值（null）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式，一种由系统自动分配，另一种由程序员指定。</p>
<p>数组在初始化数组的同时，可以指定数组的大小，也可以分别初始化数组中的每一个元素。在 Java 语言中，初始化数组有以下 3 种方式。</p>
<p><strong>1）使用 new 指定数组大小后进行初始化</strong></p>
<p>使用 new 关键字创建数组，在创建时指定数组的大小。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = new int[size];</span><br></pre></td></tr></table></figure>

<p>创建数组之后，元素的值并不确定，需要为每一个数组的元素进行赋值，其下标从 0 开始。</p>
<p><strong>例 2</strong></p>
<p>创建包含 5 个元素的 int 类型的数组，然后分别将元素的值设置为 1、2、3、5 和 8。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">number[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">number[<span class="number">4</span>] = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>如果程序员只指定了数组的长度，那么系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值。</p>
<ul>
<li>数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的值是 0。</li>
<li>数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是 0.0。</li>
<li>数组元素的类型是基本类型中的字符类型（char），则数组元素的值是‘\u0000’。</li>
<li>数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是 false。</li>
<li>数组元素的类型是引用类型（类、接口和数组），则数组元素的值是 null。</li>
</ul>
<p><strong>2）使用 new 指定数组元素的值</strong></p>
<p>使用上述方式初始化数组时，只有在为元素赋值时才确定值。可以不使用上述方式，而是在初始化时就已经确定值。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = new type[]&#123;值 1,值 2,值 3,值 4,• • •,值 n&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>例 3</strong></p>
<p>更改例 2 中的代码，使用 new 直接指定数组元素的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码的效果等价于例 2 的效果。</p>
<p>注意：不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值，这样会造成代码错误。例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">5</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,​<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3）直接指定数组元素的值</strong></p>
<p>在上述两种方式的语法中，type 可以省略，如果已经声明数组变量，那么直接使用这两种方式进行初始化。如果不想使用上述两种方式，那么可以不使用 new 直接指定数组元素的值。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = &#123;值 1,值 2,值 3,...,值 n&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>例4</strong></p>
<p>在前面例子的基础上更改代码，直接使用上述语法实现 number 数组的初始化。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>使用这种方式时，数组的声明和初始化操作要同步，即不能省略数组变量的类型。如下的代码就是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number;</span><br><span class="line">number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>获取单个元素是指获取数组中的一个元素，如第一个元素或最后一个元素。获取单个元素的方法非常简单，指定元素所在数组的下标即可。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index];</span><br></pre></td></tr></table></figure>

<p>其中，arrayName 表示数组变量，index 表示下标，下标为 0 表示获取第一个元素，下标为 array.length-1 表示获取最后一个元素。当指定的下标值超出数组的总长度时，会拋出 ArraylndexOutOfBoundsException 异常。</p>
<p><strong>例5</strong></p>
<p>获取 number 数组中的第一个元素、最后一个元素和第六个元素，并将元素的值输出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;获取第一个元素：&quot;</span>+number[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取最后一个元素：&quot;</span>+number[number.length-<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取第6个元素：&quot;</span>+number[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>执行上述代码，输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取第一个元素：1</span><br><span class="line">获取最后一个元素：8</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: 5</span><br></pre></td></tr></table></figure>

<p>我们一共存入了 5 个值，所以下标的取值为 0~4。因为 number[5] 取出的内容超过了这个下标，所以输出结果会提示数组索引超出绑定异常（ArrayIndexOutOfBoundsException）。这一点是在使用数组中是经常出现的问题，大家在编写程序时应该引起注意。</p>
<p><strong>例 6</strong></p>
<p>编写一个 Java 程序，使用数组存放录入的 5 件商品价格，然后使用下标访问第 3 个元素的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// 声明数组并分配空间</span></span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 接收用户从控制台输入的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;件商品的价格：&quot;</span>);</span><br><span class="line">            prices[i] = input.nextInt(); <span class="comment">// 接收用户从控制台输入的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第 3 件商品的价格为：&quot;</span> + prices[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的“int[] prices = new int[5]”语句创建了需要 5 个元素空间的 prices 数组，然后结合 for 循环向数组中的每个元素赋值。</p>
<p>注意：在 Java 中取得数组的长度（也就是数组元素的长度）可以利用“数组名称.length”，返回一个 int 型数据。</p>
<p>数组的索引从 0 开始，而 for 循环中的变量 i 也从 0 开始，因此 score 数组中的元素可以使用 scored 来表示，大大简化了代码。最后使用 prices[2] 获取 prices 数组的第 3 个元素，最终运行效果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请输入第1件商品的价格：</span><br><span class="line">5</span><br><span class="line">请输入第2件商品的价格：</span><br><span class="line">4</span><br><span class="line">请输入第3件商品的价格：</span><br><span class="line">6</span><br><span class="line">请输入第4件商品的价格：</span><br><span class="line">4</span><br><span class="line">请输入第5件商品的价格：</span><br><span class="line">8</span><br><span class="line">第 3 件商品的价格为：6</span><br></pre></td></tr></table></figure>

<h4 id="获取全部元素"><a href="#获取全部元素" class="headerlink" title="获取全部元素"></a>获取全部元素</h4><p>当数组中的元素数量不多时，要获取数组中的全部元素，可以使用下标逐个获取元素。但是，如果数组中的元素过多，再使用单个下标则显得烦琐，此时使用一种简单的方法可以获取全部元素——使用循环语句。</p>
<p>下面利用 for 循环语句遍历 number 数组中的全部元素，并将元素的值输出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;number.length;i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+number[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用 for 语句，还可以使用 foreach 遍历数组中的元素，并将元素的值输出。代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> val:number) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;元素的值依次是：&quot;</span>+val+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>为了方便组织各种信息，计算机常将信息以表的形式进行组织，然后再以行和列的形式呈现出来。二维数组的结构决定了其能非常方便地表示计算机中的表，以第一个下标表示元素所在的行，第二个下标表示元素所在的列。下面简单了解一下二维数组，包括数组的声明和初始化。</p>
<h4 id="创建二位数组"><a href="#创建二位数组" class="headerlink" title="创建二位数组"></a>创建二位数组</h4><p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。Java 并不直接支持二维数组，但是允许定义数组元素是一维数组的一维数组，以达到同样的效果。声明二维数组的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[][];    // 数据类型 数组名[][];</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName;    // 数据类型[][] 数组名;</span><br></pre></td></tr></table></figure>

<p>其中，type 表示二维数组的类型，arrayName 表示数组名称，第一个中括号表示行，第二个中括号表示列。</p>
<p>下面分别声明 int 类型和 char 类型的数组，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] age;</span><br><span class="line"><span class="keyword">char</span>[][] sex;</span><br></pre></td></tr></table></figure>

<h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p>二维数组可以初始化，和一维数组一样，可以通过 3 种方式来指定元素的初始值。这 3 种方式的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName = new type[][]&#123;值 1,值 2,值 3,…,值 n&#125;;    // 在定义时初始化</span><br><span class="line">type[][] arrayName = new type[size1][size2];    // 给定空间，在赋值</span><br><span class="line">type[][] arrayName = new type[size][];    // 数组第二维长度为空，可变化</span><br></pre></td></tr></table></figure>

<p><strong>例 1</strong></p>
<p>使用第一种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个二行二列的二维数组 temp，并对数组中的元素进行了初始化。图 1 所示为该数组的内存结构。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181016/3-1Q016131301F7.jpg" alt="img"></p>
<p>使用第二种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>使用第三种方式声明 int 类型的二维数组，并且初始化数组。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure>

<h4 id="获取单个元素-1"><a href="#获取单个元素-1" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>在上部分使用的前 2 种方式创建并初始化了一个二行二列的 int 类型数组 temp。当需要获取二维数组中元素的值时，也可以使用下标来表示。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[i-1][j-1];</span><br></pre></td></tr></table></figure>

<p>其中，arrayName 表示数组名称，i 表示数组的行数，j 表示数组的列数。例如，要获取第二行第二列元素的值，应该使用 temp[1] [1]来表示。这是由于数组的下标起始值为 0，因此行和列的下标需要减 1。</p>
<p><strong>例 2</strong></p>
<p>通过下标获取 class_score 数组中第二行第二列元素的值与第四行第一列元素的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123;&#123;<span class="number">10.0</span>,<span class="number">99</span>,<span class="number">99</span>&#125;,&#123;<span class="number">100</span>,<span class="number">98</span>,<span class="number">97</span>&#125;,&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">99.5</span>&#125;,&#123;<span class="number">99.5</span>,<span class="number">99</span>,<span class="number">98.5</span>&#125;&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;第二行第二列元素的值：&quot;</span>+class_score[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四行第一列元素的值：&quot;</span>+class_score[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二行第二列元素的值：98.0</span><br><span class="line">第四行第一列元素的值：99.5</span><br></pre></td></tr></table></figure>

<h4 id="获取全部元素-1"><a href="#获取全部元素-1" class="headerlink" title="获取全部元素"></a>获取全部元素</h4><p>在一维数组中直接使用数组的 length 属性获取数组元素的个数。而在二维数组中，直接使用 length 属性获取的是数组的行数，在指定的索引后加上 length（如 array[0].length）表示的是该行拥有多少个元素，即列数。</p>
<p>如果要获取二维数组中的全部元素，最简单、最常用的办法就是使用 for 语句。在一维数组全部输出时，我们使用一层 for 循环，而二维数组要想全部输出，则使用嵌套 for 循环（2 层 for 循环）。</p>
<p><strong>例 3</strong></p>
<p>使用 for 循环语句遍历 double 类型的 class_score 数组的元素，并输出每一行每一列元素的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; class_score.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; class_score[i].length; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;class_score[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;]=&quot;</span> + class_score[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码使用嵌套 for 循环语句输出二维数组。在输出二维数组时，第一个 for 循环语句表示以行进行循环，第二个 for 循环语句表示以列进行循环，这样就实现了获取二维数组中每个元素的值的功能。</p>
<p>执行上述代码，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class_score[0][0]=100.0</span><br><span class="line">class_score[0][1]=99.0</span><br><span class="line">class_score[0][2]=99.0</span><br><span class="line">class_score[1][0]=100.0</span><br><span class="line">class_score[1][1]=98.0</span><br><span class="line">class_score[1][2]=97.0</span><br><span class="line">class_score[2][0]=100.0</span><br><span class="line">class_score[2][1]=100.0</span><br><span class="line">class_score[2][2]=99.5</span><br><span class="line">class_score[3][0]=99.5</span><br><span class="line">class_score[3][1]=99.0</span><br><span class="line">class_score[3][2]=98.5</span><br></pre></td></tr></table></figure>

<p><strong>例 4</strong></p>
<p>假设有一个矩阵为 5 行 5 列，该矩阵是由程序随机产生的 10 以内数字排列而成。下面使用二维数组来创建该矩阵，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个二维矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 随机分配值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                matrix[i][j] = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;下面是程序生成的矩阵\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历二维矩阵并输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; matrix.length; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; matrix[k].length; g++) &#123;</span><br><span class="line">                System.out.print(matrix[k][g] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该程序中，首先定义了一个二维数组，然后使用两个嵌套的 for 循环向二维数组中的每个元素赋值。其中，Math.random() 方法返回的是一个 double 类型的数值，数值为 0.6、0.9 等，因此乘以 10 之后为 10 以内的整数。最后又使用了两个嵌套的 for 循环遍历二维数组，输出二维数组中的值，从而产生矩阵。</p>
<p>运行该程序的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下面是程序生成的矩阵</span><br><span class="line"></span><br><span class="line">78148</span><br><span class="line">69230</span><br><span class="line">43823</span><br><span class="line">75663</span><br><span class="line">05688</span><br></pre></td></tr></table></figure>

<p>for each 循环语句不能自动处理二维数组的每一个元素。它是按照行， 也就是一维数组处理的。要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环， 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span>[] row : a) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> value : row) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把【例2】修改为使用 for each 循环语句输出，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span>[] row : class_score) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> value : row) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">100.0</span><br><span class="line">99.0</span><br><span class="line">99.0</span><br><span class="line">100.0</span><br><span class="line">98.0</span><br><span class="line">97.0</span><br><span class="line">100.0</span><br><span class="line">100.0</span><br><span class="line">99.5</span><br><span class="line">99.5</span><br><span class="line">99.0</span><br><span class="line">98.5</span><br></pre></td></tr></table></figure>

<p>提示：要想快速地打印一个二维数组的数据元素列表，可以调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToString(arrayName));</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToString(class_score));</span><br></pre></td></tr></table></figure>

<p>输出格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[100.0, 99.0, 99.0], [100.0, 98.0, 97.0], [100.0, 100.0, 99.5], [99.5, 99.0, 98.5]]</span><br></pre></td></tr></table></figure>

<h4 id="获取整行元素"><a href="#获取整行元素" class="headerlink" title="获取整行元素"></a>获取整行元素</h4><p>除了获取单个元素和全部元素之外，还可以单独获取二维数组的某一行中所有元素的值，或者二维数组中某一列元素的值。获取指定行的元素时，需要将行数固定，然后只遍历该行中的全部列即可。</p>
<p><strong>例 5</strong></p>
<p>编写一个案例，接收用户在控制台输入的行数，然后获取该行中所有元素的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前数组只有&quot;</span> + class_score.length + <span class="string">&quot;行，您想查看第几行的元素？请输入：&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> number = scan.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; class_score[number - <span class="number">1</span>].length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + number + <span class="string">&quot;行的第[&quot;</span> + j + <span class="string">&quot;]个元素的值是：&quot;</span> + class_score[number - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码进行测试，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前数组只有4行，您想查看第几行的元素？请输入：</span><br><span class="line">3</span><br><span class="line">第3行的第[0]个元素的值是：100.0</span><br><span class="line">第3行的第[1]个元素的值是：100.0</span><br><span class="line">第3行的第[2]个元素的值是：99.5</span><br></pre></td></tr></table></figure>

<h4 id="获取整列元素"><a href="#获取整列元素" class="headerlink" title="获取整列元素"></a>获取整列元素</h4><p>获取指定列的元素与获取指定行的元素相似，保持列不变，遍历每一行的该列即可。</p>
<p><strong>例 6</strong></p>
<p>编写一个案例，接收用户在控制台中输入的列数，然后获取二维数组中所有行中该列的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;您要获取哪一列的值？请输入：&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> number = scan.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; class_score.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 行的第[&quot;</span> + number + <span class="string">&quot;]个元素的值是&quot;</span> + class_score[i][number]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码进行测试，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">您要获取哪一列的值？请输入：</span><br><span class="line">2</span><br><span class="line">第 1 行的第[2]个元素的值是99.0</span><br><span class="line">第 2 行的第[2]个元素的值是97.0</span><br><span class="line">第 3 行的第[2]个元素的值是99.5</span><br><span class="line">第 4 行的第[2]个元素的值是98.5</span><br></pre></td></tr></table></figure>

<h3 id="Java数组也是一种数据类型"><a href="#Java数组也是一种数据类型" class="headerlink" title="Java数组也是一种数据类型"></a>Java数组也是一种数据类型</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 的数组要求所有的数组元素具有相同的数据类型。因此，在一个数组中，数组元素的类型是唯一的，即一个数组里只能存储一种数据类型的数据，而不能存储多种数据类型的数据。</p>
<p>因为 Java 语言是面向对象的语言，而类与类之间可以支持继承关系（从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为），这样可能产生一个数组里可以存放多种数据类型的假象。例如有一个水果数组，要求每个数组元素都是水果，实际上数组元素既可以是苹果，也可以是香蕉（苹果、香蕉都继承了水果，都是一种特殊的水果），但这个数组的数组元素的类型还是唯一的，只能是水果类型。</p>
<p>一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度将不可改变。即使把某个数组元素的数据清空，但它所占的空间依然被保留，依然属于该数组，数组的长度依然不变。</p>
<p>Java 的数组既可以存储基本类型的数据，也可以存储引用类型的数据，只要所有的数组元素具有相同的类型即可。</p>
<p>值得指出的是，数组也是一种数据类型，它本身是一种引用类型。例如 int 是一个基本类型，但 int[]（这是定义数组的一种方式）就是一种引用类型了。</p>
<p>int[] 是一种类型吗？怎么使用这种类型呢？</p>
<p>没错，int[] 就是一种数据类型，与 int 类型、String 类型相似，一样可以使用该类型来定义变量，也可以使用该类型进行类型转换等。使用 int[] 类型来定义变量、进行类型转换时与使用其他普通类型没有任何区别。int[] 类型是一种引用类型，创建 int[] 类型的对象也就是创建数组，需要使用创建数组的语法。</p>
<h3 id="Java-Arrays工具类"><a href="#Java-Arrays工具类" class="headerlink" title="Java Arrays工具类"></a>Java Arrays工具类</h3><p>Arrays 类是一个工具类，其中包含了数组操作的很多方法。这个 Arrays 类里均为 static 修饰的方法（static 修饰的方法可以直接通过类名调用），可以直接通过 Arrays.xxx(xxx) 的形式调用方法。</p>
<h4 id="1）int-binarySearch-type-a-type-key"><a href="#1）int-binarySearch-type-a-type-key" class="headerlink" title="1）int binarySearch(type[] a, type key)"></a>1）int binarySearch(type[] a, type key)</h4><p>使用二分法查询 key 元素值在 a 数组中出现的索引，如果 a 数组不包含 key 元素值，则返回负数。调用该方法时要求数组中元素己经按升序排列，这样才能得到正确结果。</p>
<h4 id="2）int-binarySearch-type-a-int-fromIndex-int-toIndex-type-key"><a href="#2）int-binarySearch-type-a-int-fromIndex-int-toIndex-type-key" class="headerlink" title="2）int binarySearch(type[] a, int fromIndex, int toIndex, type key)"></a>2）int binarySearch(type[] a, int fromIndex, int toIndex, type key)</h4><p>这个方法与前一个方法类似，但它只搜索 a 数组中 fromIndex 到 toIndex 索引的元素。调用该方法时要求数组中元素己经按升序排列，这样才能得到正确结果。</p>
<h4 id="3）type-copyOf-type-original-int-length"><a href="#3）type-copyOf-type-original-int-length" class="headerlink" title="3）type[] copyOf(type[] original, int length)"></a>3）type[] copyOf(type[] original, int length)</h4><p>这个方法将会把 original 数组复制成一个新数组，其中 length 是新数组的长度。如果 length 小于 original 数组的长度，则新数组就是原数组的前面 length 个元素，如果 length 大于 original 数组的长度，则新数组的前面元索就是原数组的所有元素，后面补充 0（数值类型）、false（布尔类型）或者 null（引用类型）。</p>
<h4 id="4）type-copyOfRange-type-original-int-from-int-to"><a href="#4）type-copyOfRange-type-original-int-from-int-to" class="headerlink" title="4）type[] copyOfRange(type[] original, int from, int to)"></a>4）type[] copyOfRange(type[] original, int from, int to)</h4><p>这个方法与前面方法相似，但这个方法只复制 original 数组的 from 索引到 to 索引的元素。</p>
<h4 id="5）boolean-equals-type-a-type-a2"><a href="#5）boolean-equals-type-a-type-a2" class="headerlink" title="5）boolean equals(type[] a, type[] a2)"></a>5）boolean equals(type[] a, type[] a2)</h4><p>如果 a 数组和 a2 数组的长度相等，而且 a 数组和 a2 数组的数组元素也一一相同，该方法将返回 true。</p>
<h4 id="6）void-fill-type-a-type-val"><a href="#6）void-fill-type-a-type-val" class="headerlink" title="6）void fill(type[] a, type val)"></a>6）void fill(type[] a, type val)</h4><p>该方法将会把 a 数组的所有元素都赋值为 val。</p>
<h4 id="7）void-fill-type-a-int-fromIndex-int-toIndex-type-val"><a href="#7）void-fill-type-a-int-fromIndex-int-toIndex-type-val" class="headerlink" title="7）void fill(type[] a, int fromIndex, int toIndex, type val)"></a>7）void fill(type[] a, int fromIndex, int toIndex, type val)</h4><p>该方法与前一个方法的作用相同，区别只是该方法仅仅将 a 数组的 fromIndex 到 toIndex 索引的数组元素赋值为 val。</p>
<h4 id="8）void-sort-type-a"><a href="#8）void-sort-type-a" class="headerlink" title="8）void sort(type[] a)"></a>8）void sort(type[] a)</h4><p>该方法对 a 数组的数组元素进行排序。</p>
<h4 id="9）void-sort-type-a-int-fromIndex-int-toIndex"><a href="#9）void-sort-type-a-int-fromIndex-int-toIndex" class="headerlink" title="9）void sort(type[] a, int fromIndex, int toIndex)"></a>9）void sort(type[] a, int fromIndex, int toIndex)</h4><p>该方法与前一个方法相似，区别是该方法仅仅对 fromIndex 到 toIndex 索引的元素进行排序。</p>
<h4 id="10）String-toString-type-a"><a href="#10）String-toString-type-a" class="headerlink" title="10）String toString(type[] a)"></a>10）String toString(type[] a)</h4><p>该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起，多个数组元素使用英文逗号<code>,</code>和空格隔开。</p>
<hr>
<p><strong>下面程序示范了 Arrays 类的用法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个a数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="comment">// 定义一个a2数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="comment">// a数组和a2数组的长度相等，毎个元素依次相等，将输出true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a数组和a2数组是否相等：&quot;</span> + Arrays.equals(a, a2));</span><br><span class="line">        <span class="comment">// 通过复制a数组，生成一个新的b数组</span></span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a数组和b数组是否相等：&quot;</span> + Arrays.equals(a, b));</span><br><span class="line">        <span class="comment">// 输出b数组的元素，将输出[3, 4, 5, 6, 0, 0]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b 数组的元素为：&quot;</span> + Arrays.toString(b));</span><br><span class="line">        <span class="comment">// 将b数组的第3个元素（包括）到第5个元素（不包括）賦值为1</span></span><br><span class="line">        Arrays.fill(b, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 输出b数组的元素，将输出[3, 4, 1, 1, 0, 0]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b 数组的元素为：&quot;</span> + Arrays.toString(b));</span><br><span class="line">        <span class="comment">// 对b数组进行排序</span></span><br><span class="line">        Arrays.sort(b);</span><br><span class="line">        <span class="comment">// 输出b数组的元素.将输出[0,0,1,1,3,4]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b数组的元素为：&quot;</span> + Arrays.toString(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arrays 类处于 java.util 包下，为了在程序中使用 Arrays 类，必须在程序中导入 java.util.Arrays 类。</p>
<p>除此之外，在 System 类里也包含了一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void arraycopy(Object src, int srePos, Object dest, int dcstPos, int length)</span><br></pre></td></tr></table></figure>

<p>方法，该方法可以将 src 数组里的元素值赋给 dest 数组的元素，其中 srcPos 指定从 src 数组的第几个元素开始赋值，length 参数指定将 src 数组的多少个元素值赋给 dest 数组的元素。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 8 增强了 Arrays 类的功能，为 Arrays 类增加了一些工具方法，这些工具方法可以充分利用多 CPU 并行的能力来提高设值、排序的性能。下面是 Java 8 为 Arrays 类增加的工具方法。</p>
<p>提示：由于计算机硬件的飞速发展，目前几乎所有家用 PC 都是 4 核、8 核的 CPU，而服务器的 CPU 则具有更好的性能，因此 Java 8 与时俱进地增加了并发支持，并发支持可以充分利用硬件设备来提高程序的运行性能。</p>
<h3 id="Java冒泡排序法（非常重要）"><a href="#Java冒泡排序法（非常重要）" class="headerlink" title="Java冒泡排序法（非常重要）"></a>Java冒泡排序法（非常重要）</h3><p>冒泡排序（Bubble Sort）是常用的数组排序算法之一，它以简洁的思想与实现方法而备受青睐，也是广大学习者最先接触的一种排序算法。</p>
<p>冒泡排序的基本思想是：对比相邻的元素值，如果满足条件就交换元素值，把较小的元素值移动到数组前面，把大的元素值移动到数组后面（也就是交换两个元素的位置），这样数组元素就像气泡一样从底部上升到顶部。</p>
<p>冒泡排序的算法比较简单，排序的结果稳定，但时间效率不太高。<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 中的冒泡排序在双层循环中实现，其中外层循环控制排序轮数，总循环次数为要排序数组的长度减 1。而内层循环主要用于对比相邻元素的大小，以确定是否交换位置，对比和交换次数依排序轮数而减少。</p>
<p><strong>例 1</strong></p>
<p>获取用户在控制台输入的 5 个成绩信息，将这些成绩保存到数组中，然后对数组应用冒泡排序，并输出排序后的结果，实现步骤如下。</p>
<p>(1) 创建一个 Test24 类文件，在 main() 方法中开始编码。首先创建 Scanner 类的实例后声明 double 类型的 score 数组，然后接收用户在控制台输入的成绩，并保存到元素中。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">double</span>[] score = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; score.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 个成绩：&quot;</span>);</span><br><span class="line">        score[i] = scan.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 在对 score 数组排序之前，首先输出数组中各个元素的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;排序前的元素值：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> val:score) &#123;</span><br><span class="line">    System.out.print(val+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<p>(3) 通过冒泡排序方法实现对 score 数组的排序，在实现时需要借助一个临时变量。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;通过冒泡排序方法对数组进行排序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; score.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 比较相邻两个元素，较大的数往后冒泡</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; score.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score[j] &gt; score[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">double</span> temp = score[j + <span class="number">1</span>]; <span class="comment">// 把第一个元素值保存到临时变量中</span></span><br><span class="line">                score[j + <span class="number">1</span>] = score[j]; <span class="comment">// 把第二个元素值转移到第一个元素变量中</span></span><br><span class="line">                score[j] = temp; <span class="comment">// 把临时变量（第一个元素的原值）保存到第二个元素中</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(score[j] + <span class="string">&quot; &quot;</span>); <span class="comment">// 对排序后的数组元素进行输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;【&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = score.length - <span class="number">1</span> - i; j &lt; score.length; j++) &#123;</span><br><span class="line">            System.out.print(score[j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4) 运行前面的代码进行测试，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请输入第 1 个成绩：77</span><br><span class="line">请输入第 2 个成绩：90</span><br><span class="line">请输入第 3 个成绩：68</span><br><span class="line">请输入第 4 个成绩：59</span><br><span class="line">请输入第 5 个成绩：80</span><br><span class="line">排序前的元素值：</span><br><span class="line">77.0    90.0    68.0    59.0    80.0   </span><br><span class="line">通过冒泡排序方法对数组进行排序：</span><br><span class="line">77.0 68.0 59.0 80.0 【90.0 】</span><br><span class="line">68.0 59.0 77.0 【80.0 90.0 】</span><br><span class="line">59.0 68.0 【77.0 80.0 90.0 】</span><br><span class="line">59.0 【68.0 77.0 80.0 90.0 】</span><br></pre></td></tr></table></figure>

<h4 id="Java快速排序法（Quicksort）"><a href="#Java快速排序法（Quicksort）" class="headerlink" title="Java快速排序法（Quicksort）"></a>Java快速排序法（Quicksort）</h4><p>快速排序（Quicksort）是对冒泡排序的一种改进，是一种排序执行效率很高的排序算法。</p>
<p>快速排序的基本思想是：通过一趟排序，将要排序的数据分隔成独立的两部分，其中一部分的所有数据比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此使整个数据变成有序序列。</p>
<p>具体做法是：假设要对某个数组进行排序，首先需要任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它的前面，所有比它大的数都放到它的后面。这个过程称为一趟快速排序；递归调用此过程，即可实现数据的快速排序。</p>
<p><strong>例 1</strong></p>
<p>利用快速排序法对一数组进行排序，实现步骤如下。</p>
<p>(1) 声明静态的 getMiddle() 方法，该方法需要返回一个 int 类型的参数值，在该方法中传入 3 个参数。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = list[low]; <span class="comment">// 数组的第一个值作为中轴（分界点或关键数据）</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; list[high] &gt; tmp) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        list[low] = list[high]; <span class="comment">// 比中轴小的记录移到低端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; list[low] &lt; tmp) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        list[high] = list[low]; <span class="comment">// 比中轴大的记录移到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    list[low] = tmp; <span class="comment">// 中轴记录到尾</span></span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">// 返回中轴的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 创建静态的 unckSort() 方法，在该方法中判断 low 参数是否小于 high 参数，如果是则调用 getMiddle() 方法，将数组一分为二，并且调用自身的方法进行递归排序。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unckSort</span><span class="params">(<span class="keyword">int</span>[] list,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = getMiddle(list,low,high);    <span class="comment">// 将list数组一分为二</span></span><br><span class="line">        unckSort(list,low,middle-<span class="number">1</span>);    <span class="comment">// 对低字表进行递归排序</span></span><br><span class="line">        unckSort(list,middle+<span class="number">1</span>,high);    <span class="comment">// 对高字表进行递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 声明静态的 quick() 方法，在该方法中判断传入的数组是否为空，如果不为空，则调用 unckSort() 方法进行排序。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 查看数组是否为空</span></span><br><span class="line">        unckSort(str,<span class="number">0</span>,str.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4) 在 main() 方法中声明 int 类型的 number 数组，接着输出该数组中的元素。然后调用自定义的 quick() 方法进行排序，排序后重新输出数组中的元素。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number=&#123;<span class="number">13</span>,<span class="number">15</span>,<span class="number">24</span>,<span class="number">99</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> val:number) &#123;</span><br><span class="line">    System.out.print(val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">quick(number);</span><br><span class="line">System.out.println(<span class="string">&quot;\n排序后：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> val:number) &#123;</span><br><span class="line">    System.out.print(val +<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行前面的代码进行测试，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前：</span><br><span class="line">13 15 24 99 14 11 1 2 3</span><br><span class="line">排序后：</span><br><span class="line">1 2 3 11 13 14 15 24 99 </span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Future-T</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/13/Java%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/">http://yoursite.com/2020/05/13/Java%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Future-tt</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E7%AC%94%E8%AE%B0/">Java笔记</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/05/14/Y08rvD.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05/13/Java%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><img class="prev-cover" src="/img/04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java笔记-面向对象</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/12/Java%E7%AC%94%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"><img class="next-cover" src="https://i.loli.net/2021/09/19/Zj9DFYNqWpzkUvd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java笔记-循环语句</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/24/Java%E7%AC%94%E8%AE%B0-File%E7%B1%BB/" title="Java笔记-File类"><img class="cover" src="https://s1.ax1x.com/2020/07/24/UXc458.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-24</div><div class="title">Java笔记-File类</div></div></a></div><div><a href="/2020/07/26/Java%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95%E7%B1%BB/" title="Java笔记-Junit测试类"><img class="cover" src="https://s1.ax1x.com/2020/07/26/aC6I4s.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-26</div><div class="title">Java笔记-Junit测试类</div></div></a></div><div><a href="/2020/05/12/Java%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="Java笔记-数据类型"><img class="cover" src="https://i.loli.net/2021/09/19/Zj9DFYNqWpzkUvd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-12</div><div class="title">Java笔记-数据类型</div></div></a></div><div><a href="/2020/05/24/Java%E7%AC%94%E8%AE%B0-%E7%AE%80%E5%8D%95%E7%9A%84TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/" title="Java笔记-简单的TCP通信程序（一）"><img class="cover" src="https://cdn.jsdelivr.net/gh/Future-tt/images/img/tcp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-24</div><div class="title">Java笔记-简单的TCP通信程序（一）</div></div></a></div><div><a href="/2020/05/27/Java%E7%AC%94%E8%AE%B0-%E7%AE%80%E5%8D%95%E7%9A%84TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Java笔记-简单的TCP通信程序（二）"><img class="cover" src="https://cdn.jsdelivr.net/gh/Future-tt/images/img/tcp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-27</div><div class="title">Java笔记-简单的TCP通信程序（二）</div></div></a></div><div><a href="/2020/05/18/Java%E7%AC%94%E8%AE%B0-%E7%B1%BB/" title="Java笔记-类"><img class="cover" src="https://s1.ax1x.com/2020/05/18/Yh9Njg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-18</div><div class="title">Java笔记-类</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Future-T</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Future-tt"><i class="fab fa-github"></i><span>关注我呀！！</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Future-tt" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">初始化一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.3.</span> <span class="toc-text">获取单个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%A8%E9%83%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.4.</span> <span class="toc-text">获取全部元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E4%BD%8D%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建二位数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">初始化二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">获取单个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%A8%E9%83%A8%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">获取全部元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B4%E8%A1%8C%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.5.</span> <span class="toc-text">获取整行元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B4%E5%88%97%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.6.</span> <span class="toc-text">获取整列元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%95%B0%E7%BB%84%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Java数组也是一种数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">Java Arrays工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89int-binarySearch-type-a-type-key"><span class="toc-number">1.4.1.</span> <span class="toc-text">1）int binarySearch(type[] a, type key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89int-binarySearch-type-a-int-fromIndex-int-toIndex-type-key"><span class="toc-number">1.4.2.</span> <span class="toc-text">2）int binarySearch(type[] a, int fromIndex, int toIndex, type key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89type-copyOf-type-original-int-length"><span class="toc-number">1.4.3.</span> <span class="toc-text">3）type[] copyOf(type[] original, int length)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89type-copyOfRange-type-original-int-from-int-to"><span class="toc-number">1.4.4.</span> <span class="toc-text">4）type[] copyOfRange(type[] original, int from, int to)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89boolean-equals-type-a-type-a2"><span class="toc-number">1.4.5.</span> <span class="toc-text">5）boolean equals(type[] a, type[] a2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%89void-fill-type-a-type-val"><span class="toc-number">1.4.6.</span> <span class="toc-text">6）void fill(type[] a, type val)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%EF%BC%89void-fill-type-a-int-fromIndex-int-toIndex-type-val"><span class="toc-number">1.4.7.</span> <span class="toc-text">7）void fill(type[] a, int fromIndex, int toIndex, type val)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%EF%BC%89void-sort-type-a"><span class="toc-number">1.4.8.</span> <span class="toc-text">8）void sort(type[] a)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%EF%BC%89void-sort-type-a-int-fromIndex-int-toIndex"><span class="toc-number">1.4.9.</span> <span class="toc-text">9）void sort(type[] a, int fromIndex, int toIndex)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%EF%BC%89String-toString-type-a"><span class="toc-number">1.4.10.</span> <span class="toc-text">10）String toString(type[] a)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">Java冒泡排序法（非常重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88Quicksort%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">Java快速排序法（Quicksort）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/04/28/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/" title="生活小记"><img src="https://i.loli.net/2021/09/19/Zj9DFYNqWpzkUvd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="生活小记"/></a><div class="content"><a class="title" href="/2021/04/28/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/" title="生活小记">生活小记</a><time datetime="2021-04-28T09:56:05.000Z" title="发表于 2021-04-28 17:56:05">2021-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/04/hdshfhhsdn/" title="hdshfhhsdn"><img src="https://i.loli.net/2021/09/19/Zj9DFYNqWpzkUvd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hdshfhhsdn"/></a><div class="content"><a class="title" href="/2020/10/04/hdshfhhsdn/" title="hdshfhhsdn">hdshfhhsdn</a><time datetime="2020-10-03T16:39:45.000Z" title="发表于 2020-10-04 00:39:45">2020-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/30/JSP%E5%85%A5%E9%97%A8/" title="JSP入门"><img src="https://i.loli.net/2021/09/19/Zj9DFYNqWpzkUvd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JSP入门"/></a><div class="content"><a class="title" href="/2020/09/30/JSP%E5%85%A5%E9%97%A8/" title="JSP入门">JSP入门</a><time datetime="2020-09-30T13:45:17.000Z" title="发表于 2020-09-30 21:45:17">2020-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/29/%E5%BC%80%E5%A7%8B%E6%97%A2%E6%98%AF%E7%BB%93%E6%9D%9F/" title="开始既是结束"><img src="https://s1.ax1x.com/2020/09/30/0uwEY8.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开始既是结束"/></a><div class="content"><a class="title" href="/2020/09/29/%E5%BC%80%E5%A7%8B%E6%97%A2%E6%98%AF%E7%BB%93%E6%9D%9F/" title="开始既是结束">开始既是结束</a><time datetime="2020-09-29T10:55:50.000Z" title="发表于 2020-09-29 18:55:50">2020-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/06/%E5%BC%80%E5%AD%A6%E4%BA%86%EF%BC%81/" title="开学了！"><img src="https://s1.ax1x.com/2020/05/20/Yoa6Qs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开学了！"/></a><div class="content"><a class="title" href="/2020/09/06/%E5%BC%80%E5%AD%A6%E4%BA%86%EF%BC%81/" title="开学了！">开学了！</a><time datetime="2020-09-06T11:05:52.000Z" title="发表于 2020-09-06 19:05:52">2020-09-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/09/19/MWqPrkYJSbwslEX.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Future-T</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '55vU6Rs4CMk2vMFL5s6ufH71-gzGzoHsz',
      appKey: 'YubiGKKvAigM2WrW6qFgOLng',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/yinghua.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="祝你呀！,身体健康,万事如意,永远不死,永远不死！！！" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>